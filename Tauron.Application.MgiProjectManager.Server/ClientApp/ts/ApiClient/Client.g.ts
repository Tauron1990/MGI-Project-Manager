/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.1.0.0 (NJsonSchema v9.13.28.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import * as jQuery from 'jquery';

export module ApiModule {

export class UserClient {
    baseUrl: string; 
    beforeSend: any = undefined; 
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:40000";
    }

    get() {
        return new Promise<UserList | null>((resolve, reject) => {
            this.getWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }
    
    private getWithCallbacks(onSuccess?: (result: UserList | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/User";
        url_ = url_.replace(/[?&]$/, "");

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "get",
            dataType: "text",
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGetWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGetWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGet(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGet(xhr: any): UserList | null | null {
        const status = xhr.status; 

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserList.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class UserGridClient {
    baseUrl: string; 
    beforeSend: any = undefined; 
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:40000";
    }

    gridGetData(dm: DataManagerRequest) {
        return new Promise<any | null>((resolve, reject) => {
            this.gridGetDataWithCallbacks(dm, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }
    
    private gridGetDataWithCallbacks(dm: DataManagerRequest, onSuccess?: (result: any | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/UserGrid";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dm);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGridGetDataWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGridGetDataWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGridGetDataWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGridGetData(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGridGetData(xhr: any): any | null | null {
        const status = xhr.status; 

        let _headers: any = {};
        if (status === 200 || status === 206) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    gridUpdateData(userValue: AppUserValue) {
        return new Promise<any | null>((resolve, reject) => {
            this.gridUpdateDataWithCallbacks(userValue, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }
    
    private gridUpdateDataWithCallbacks(userValue: AppUserValue, onSuccess?: (result: any | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/UserGrid/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userValue);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGridUpdateDataWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGridUpdateDataWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGridUpdateDataWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGridUpdateData(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGridUpdateData(xhr: any): any | null | null {
        const status = xhr.status; 

        let _headers: any = {};
        if (status === 200 || status === 206) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    gridAddData(userValue: AppUserValue) {
        return new Promise<any | null>((resolve, reject) => {
            this.gridAddDataWithCallbacks(userValue, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }
    
    private gridAddDataWithCallbacks(userValue: AppUserValue, onSuccess?: (result: any | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/UserGrid/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userValue);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGridAddDataWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGridAddDataWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGridAddDataWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGridAddData(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGridAddData(xhr: any): any | null | null {
        const status = xhr.status; 

        let _headers: any = {};
        if (status === 200 || status === 206) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }

    gridRemoveData(user: AppUserKey) {
        return new Promise<any | null>((resolve, reject) => {
            this.gridRemoveDataWithCallbacks(user, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }
    
    private gridRemoveDataWithCallbacks(user: AppUserKey, onSuccess?: (result: any | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/UserGrid/Remove";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(user);

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            dataType: "text",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processGridRemoveDataWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGridRemoveDataWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processGridRemoveDataWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processGridRemoveData(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processGridRemoveData(xhr: any): any | null | null {
        const status = xhr.status; 

        let _headers: any = {};
        if (status === 200 || status === 206) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class FilesClient {
    baseUrl: string; 
    beforeSend: any = undefined; 
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:40000";
    }

    uploadFiles(files: FileParameter[] | null | undefined) {
        return new Promise<UploadResult | null>((resolve, reject) => {
            this.uploadFilesWithCallbacks(files, (result) => resolve(result), (exception, _reason) => reject(exception));
        });
    }
    
    private uploadFilesWithCallbacks(files: FileParameter[] | null | undefined, onSuccess?: (result: UploadResult | null) => void, onFail?: (exception: string, reason: string) => void) {
        let url_ = this.baseUrl + "/api/Files";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (files !== null && files !== undefined)
            files.forEach(item_ => content_.append("Files", item_.data, item_.fileName ? item_.fileName : "Files") );

        jQuery.ajax({
            url: url_,
            beforeSend: this.beforeSend,
            type: "post",
            data: content_,
            mimeType: "multipart/form-data",
            contentType: false,
            headers: {
                "Accept": "application/json"
            }
        }).done((_data, _textStatus, xhr) => {
            this.processUploadFilesWithCallbacks(url_, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processUploadFilesWithCallbacks(url_, xhr, onSuccess, onFail);
        });
    }

    private processUploadFilesWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
        try {
            let result = this.processUploadFiles(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    protected processUploadFiles(xhr: any): UploadResult | null | null {
        const status = xhr.status; 

        let _headers: any = {};
        if (status === 200) {
            const _responseText = xhr.responseText;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UploadResult.fromJS(resultData200) : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = xhr.responseText;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return null;
    }
}

export class UserList implements IUserList {
    items?: AppUser[] | null;
    count!: number;

    constructor(data?: IUserList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["Items"] && data["Items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["Items"])
                    this.items!.push(AppUser.fromJS(item));
            }
            this.count = data["Count"] !== undefined ? data["Count"] : <any>null;
        }
    }

    static fromJS(data: any): UserList {
        data = typeof data === 'object' ? data : {};
        let result = new UserList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["Items"] = [];
            for (let item of this.items)
                data["Items"].push(item.toJSON());
        }
        data["Count"] = this.count !== undefined ? this.count : <any>null;
        return data; 
    }
}

export interface IUserList {
    items?: AppUser[] | null;
    count: number;
}

export class AppUser implements IAppUser {
    id?: string | null;
    email?: string | null;
    name?: string | null;
    role?: string | null;

    constructor(data?: IAppUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"] !== undefined ? data["Id"] : <any>null;
            this.email = data["Email"] !== undefined ? data["Email"] : <any>null;
            this.name = data["Name"] !== undefined ? data["Name"] : <any>null;
            this.role = data["Role"] !== undefined ? data["Role"] : <any>null;
        }
    }

    static fromJS(data: any): AppUser {
        data = typeof data === 'object' ? data : {};
        let result = new AppUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id !== undefined ? this.id : <any>null;
        data["Email"] = this.email !== undefined ? this.email : <any>null;
        data["Name"] = this.name !== undefined ? this.name : <any>null;
        data["Role"] = this.role !== undefined ? this.role : <any>null;
        return data; 
    }
}

export interface IAppUser {
    id?: string | null;
    email?: string | null;
    name?: string | null;
    role?: string | null;
}

export class DataManagerRequest implements IDataManagerRequest {
    skip!: number;
    take!: number;
    antiForgery?: string | null;
    requiresCounts!: boolean;
    table?: string | null;
    group?: string[] | null;
    select?: string[] | null;
    expand?: string[] | null;
    sorted?: Sort[] | null;
    search?: SearchFilter[] | null;
    where?: WhereFilter[] | null;
    aggregates?: Aggregate[] | null;

    constructor(data?: IDataManagerRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.skip = data["skip"] !== undefined ? data["skip"] : <any>null;
            this.take = data["take"] !== undefined ? data["take"] : <any>null;
            this.antiForgery = data["antiForgery"] !== undefined ? data["antiForgery"] : <any>null;
            this.requiresCounts = data["requiresCounts"] !== undefined ? data["requiresCounts"] : <any>null;
            this.table = data["table"] !== undefined ? data["table"] : <any>null;
            if (data["group"] && data["group"].constructor === Array) {
                this.group = [] as any;
                for (let item of data["group"])
                    this.group!.push(item);
            }
            if (data["select"] && data["select"].constructor === Array) {
                this.select = [] as any;
                for (let item of data["select"])
                    this.select!.push(item);
            }
            if (data["expand"] && data["expand"].constructor === Array) {
                this.expand = [] as any;
                for (let item of data["expand"])
                    this.expand!.push(item);
            }
            if (data["sorted"] && data["sorted"].constructor === Array) {
                this.sorted = [] as any;
                for (let item of data["sorted"])
                    this.sorted!.push(Sort.fromJS(item));
            }
            if (data["search"] && data["search"].constructor === Array) {
                this.search = [] as any;
                for (let item of data["search"])
                    this.search!.push(SearchFilter.fromJS(item));
            }
            if (data["where"] && data["where"].constructor === Array) {
                this.where = [] as any;
                for (let item of data["where"])
                    this.where!.push(WhereFilter.fromJS(item));
            }
            if (data["aggregates"] && data["aggregates"].constructor === Array) {
                this.aggregates = [] as any;
                for (let item of data["aggregates"])
                    this.aggregates!.push(Aggregate.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DataManagerRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DataManagerRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skip"] = this.skip !== undefined ? this.skip : <any>null;
        data["take"] = this.take !== undefined ? this.take : <any>null;
        data["antiForgery"] = this.antiForgery !== undefined ? this.antiForgery : <any>null;
        data["requiresCounts"] = this.requiresCounts !== undefined ? this.requiresCounts : <any>null;
        data["table"] = this.table !== undefined ? this.table : <any>null;
        if (this.group && this.group.constructor === Array) {
            data["group"] = [];
            for (let item of this.group)
                data["group"].push(item);
        }
        if (this.select && this.select.constructor === Array) {
            data["select"] = [];
            for (let item of this.select)
                data["select"].push(item);
        }
        if (this.expand && this.expand.constructor === Array) {
            data["expand"] = [];
            for (let item of this.expand)
                data["expand"].push(item);
        }
        if (this.sorted && this.sorted.constructor === Array) {
            data["sorted"] = [];
            for (let item of this.sorted)
                data["sorted"].push(item.toJSON());
        }
        if (this.search && this.search.constructor === Array) {
            data["search"] = [];
            for (let item of this.search)
                data["search"].push(item.toJSON());
        }
        if (this.where && this.where.constructor === Array) {
            data["where"] = [];
            for (let item of this.where)
                data["where"].push(item.toJSON());
        }
        if (this.aggregates && this.aggregates.constructor === Array) {
            data["aggregates"] = [];
            for (let item of this.aggregates)
                data["aggregates"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDataManagerRequest {
    skip: number;
    take: number;
    antiForgery?: string | null;
    requiresCounts: boolean;
    table?: string | null;
    group?: string[] | null;
    select?: string[] | null;
    expand?: string[] | null;
    sorted?: Sort[] | null;
    search?: SearchFilter[] | null;
    where?: WhereFilter[] | null;
    aggregates?: Aggregate[] | null;
}

export class Sort implements ISort {
    name?: string | null;
    direction?: string | null;

    constructor(data?: ISort) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["Name"] !== undefined ? data["Name"] : <any>null;
            this.direction = data["Direction"] !== undefined ? data["Direction"] : <any>null;
        }
    }

    static fromJS(data: any): Sort {
        data = typeof data === 'object' ? data : {};
        let result = new Sort();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name !== undefined ? this.name : <any>null;
        data["Direction"] = this.direction !== undefined ? this.direction : <any>null;
        return data; 
    }
}

export interface ISort {
    name?: string | null;
    direction?: string | null;
}

export class SearchFilter implements ISearchFilter {
    fields?: string[] | null;
    key?: string | null;
    operator?: string | null;

    constructor(data?: ISearchFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["Fields"] && data["Fields"].constructor === Array) {
                this.fields = [] as any;
                for (let item of data["Fields"])
                    this.fields!.push(item);
            }
            this.key = data["Key"] !== undefined ? data["Key"] : <any>null;
            this.operator = data["Operator"] !== undefined ? data["Operator"] : <any>null;
        }
    }

    static fromJS(data: any): SearchFilter {
        data = typeof data === 'object' ? data : {};
        let result = new SearchFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.fields && this.fields.constructor === Array) {
            data["Fields"] = [];
            for (let item of this.fields)
                data["Fields"].push(item);
        }
        data["Key"] = this.key !== undefined ? this.key : <any>null;
        data["Operator"] = this.operator !== undefined ? this.operator : <any>null;
        return data; 
    }
}

export interface ISearchFilter {
    fields?: string[] | null;
    key?: string | null;
    operator?: string | null;
}

export class WhereFilter implements IWhereFilter {
    field?: string | null;
    ignoreCase!: boolean;
    isComplex!: boolean;
    operator?: string | null;
    condition?: string | null;
    value?: any | null;
    predicates?: WhereFilter[] | null;

    constructor(data?: IWhereFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.field = data["Field"] !== undefined ? data["Field"] : <any>null;
            this.ignoreCase = data["IgnoreCase"] !== undefined ? data["IgnoreCase"] : <any>null;
            this.isComplex = data["IsComplex"] !== undefined ? data["IsComplex"] : <any>null;
            this.operator = data["Operator"] !== undefined ? data["Operator"] : <any>null;
            this.condition = data["Condition"] !== undefined ? data["Condition"] : <any>null;
            this.value = data["value"] !== undefined ? data["value"] : <any>null;
            if (data["predicates"] && data["predicates"].constructor === Array) {
                this.predicates = [] as any;
                for (let item of data["predicates"])
                    this.predicates!.push(WhereFilter.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WhereFilter {
        data = typeof data === 'object' ? data : {};
        let result = new WhereFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Field"] = this.field !== undefined ? this.field : <any>null;
        data["IgnoreCase"] = this.ignoreCase !== undefined ? this.ignoreCase : <any>null;
        data["IsComplex"] = this.isComplex !== undefined ? this.isComplex : <any>null;
        data["Operator"] = this.operator !== undefined ? this.operator : <any>null;
        data["Condition"] = this.condition !== undefined ? this.condition : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        if (this.predicates && this.predicates.constructor === Array) {
            data["predicates"] = [];
            for (let item of this.predicates)
                data["predicates"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IWhereFilter {
    field?: string | null;
    ignoreCase: boolean;
    isComplex: boolean;
    operator?: string | null;
    condition?: string | null;
    value?: any | null;
    predicates?: WhereFilter[] | null;
}

export class Aggregate implements IAggregate {
    field?: string | null;
    type?: string | null;

    constructor(data?: IAggregate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.field = data["Field"] !== undefined ? data["Field"] : <any>null;
            this.type = data["Type"] !== undefined ? data["Type"] : <any>null;
        }
    }

    static fromJS(data: any): Aggregate {
        data = typeof data === 'object' ? data : {};
        let result = new Aggregate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Field"] = this.field !== undefined ? this.field : <any>null;
        data["Type"] = this.type !== undefined ? this.type : <any>null;
        return data; 
    }
}

export interface IAggregate {
    field?: string | null;
    type?: string | null;
}

export class AppUserValue implements IAppUserValue {
    value?: AppUser | null;

    constructor(data?: IAppUserValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["Value"] ? AppUser.fromJS(data["Value"]) : <any>null;
        }
    }

    static fromJS(data: any): AppUserValue {
        data = typeof data === 'object' ? data : {};
        let result = new AppUserValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Value"] = this.value ? this.value.toJSON() : <any>null;
        return data; 
    }
}

export interface IAppUserValue {
    value?: AppUser | null;
}

export class AppUserKey implements IAppUserKey {
    key?: string | null;

    constructor(data?: IAppUserKey) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["Key"] !== undefined ? data["Key"] : <any>null;
        }
    }

    static fromJS(data: any): AppUserKey {
        data = typeof data === 'object' ? data : {};
        let result = new AppUserKey();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Key"] = this.key !== undefined ? this.key : <any>null;
        return data; 
    }
}

export interface IAppUserKey {
    key?: string | null;
}

export class UploadResult implements IUploadResult {
    errors?: { [key: string] : string; } | null;
    message?: string | null;
    operation?: string | null;

    constructor(data?: IUploadResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["Errors"]) {
                this.errors = {} as any;
                for (let key in data["Errors"]) {
                    if (data["Errors"].hasOwnProperty(key))
                        this.errors![key] = data["Errors"][key];
                }
            }
            this.message = data["Message"] !== undefined ? data["Message"] : <any>null;
            this.operation = data["Operation"] !== undefined ? data["Operation"] : <any>null;
        }
    }

    static fromJS(data: any): UploadResult {
        data = typeof data === 'object' ? data : {};
        let result = new UploadResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.errors) {
            data["Errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    data["Errors"][key] = this.errors[key] !== undefined ? this.errors[key] : <any>null;
            }
        }
        data["Message"] = this.message !== undefined ? this.message : <any>null;
        data["Operation"] = this.operation !== undefined ? this.operation : <any>null;
        return data; 
    }
}

export interface IUploadResult {
    errors?: { [key: string] : string; } | null;
    message?: string | null;
    operation?: string | null;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if(result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}

}