/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.1.0.0 (NJsonSchema v9.13.28.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';

export module ApiModule {

export class FilesClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param files (optional) 
     * @return Success
     */
    files(files: any[] | null | undefined): Promise<UploadResult> {
        let url_ = this.baseUrl + "/api/Files";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (files !== null && files !== undefined)
            content_.append("files", files.toString());

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processFiles(_response);
        });
    }

    protected processFiles(response: AxiosResponse): Promise<UploadResult> {
        const status = response.status;
        let _headers: any = {}; 
        if (response.headers && response.headers.forEach) { 
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        };
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 ? UploadResult.fromJS(resultData200) : new UploadResult();
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UploadResult>(<any>null);
    }

    /**
     * @param opId (optional) 
     * @return Success
     */
    getUnAssociateFiles(opId: string | null | undefined): Promise<UnAssociateFile[]> {
        let url_ = this.baseUrl + "/api/Files/GetUnAssociateFiles?";
        if (opId !== undefined)
            url_ += "opId=" + encodeURIComponent("" + opId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetUnAssociateFiles(_response);
        });
    }

    protected processGetUnAssociateFiles(response: AxiosResponse): Promise<UnAssociateFile[]> {
        const status = response.status;
        let _headers: any = {}; 
        if (response.headers && response.headers.forEach) { 
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        };
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UnAssociateFile.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UnAssociateFile[]>(<any>null);
    }

    /**
     * @param file (optional) 
     * @return Success
     */
    postAssociateFile(file: AssociateFile | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Files/PostAssociateFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(file);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processPostAssociateFile(_response);
        });
    }

    protected processPostAssociateFile(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {}; 
        if (response.headers && response.headers.forEach) { 
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        };
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    startMultifile(id: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Files/StartMultifile?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processStartMultifile(_response);
        });
    }

    protected processStartMultifile(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {}; 
        if (response.headers && response.headers.forEach) { 
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        };
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class TemplateClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param jObject (optional) 
     * @return Success
     */
    adminGridError(jObject: string | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Template/AdminGridError?";
        if (jObject !== undefined)
            url_ += "jObject=" + encodeURIComponent("" + jObject) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processAdminGridError(_response);
        });
    }

    protected processAdminGridError(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {}; 
        if (response.headers && response.headers.forEach) { 
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        };
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * @param result (optional) 
     * @return Success
     */
    fileUploadError(result: UploadResult | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Template/FileUploadError";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(result);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processFileUploadError(_response);
        });
    }

    protected processFileUploadError(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {}; 
        if (response.headers && response.headers.forEach) { 
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        };
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * @param file (optional) 
     * @return Success
     */
    linkingFileTemplate(file: UnAssociateFile | null | undefined): Promise<FileToNameTemplate> {
        let url_ = this.baseUrl + "/api/Template/LinkingFileTemplate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(file);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processLinkingFileTemplate(_response);
        });
    }

    protected processLinkingFileTemplate(response: AxiosResponse): Promise<FileToNameTemplate> {
        const status = response.status;
        let _headers: any = {}; 
        if (response.headers && response.headers.forEach) { 
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        };
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 ? FileToNameTemplate.fromJS(resultData200) : new FileToNameTemplate();
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileToNameTemplate>(<any>null);
    }
}

export class UserClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    user(): Promise<UserList> {
        let url_ = this.baseUrl + "/api/User";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processUser(_response);
        });
    }

    protected processUser(response: AxiosResponse): Promise<UserList> {
        const status = response.status;
        let _headers: any = {}; 
        if (response.headers && response.headers.forEach) { 
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        };
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 ? UserList.fromJS(resultData200) : new UserList();
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserList>(<any>null);
    }
}

export class UserGridClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param dm (optional) 
     * @return Success
     */
    userGrid(dm: DataManagerRequest | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/UserGrid";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dm);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processUserGrid(_response);
        });
    }

    protected processUserGrid(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {}; 
        if (response.headers && response.headers.forEach) { 
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        };
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param userValue (optional) 
     * @return Success
     */
    update(userValue: AppUserValue | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/UserGrid/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userValue);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {}; 
        if (response.headers && response.headers.forEach) { 
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        };
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param userValue (optional) 
     * @return Success
     */
    insert(userValue: AppUserValue | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/UserGrid/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userValue);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processInsert(_response);
        });
    }

    protected processInsert(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {}; 
        if (response.headers && response.headers.forEach) { 
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        };
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param user (optional) 
     * @return Success
     */
    remove(user: AppUserKey | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/UserGrid/Remove";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(user);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processRemove(_response);
        });
    }

    protected processRemove(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {}; 
        if (response.headers && response.headers.forEach) { 
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        };
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class IFormFile implements IIFormFile {
    contentType?: string | null;
    contentDisposition?: string | null;
    headers?: { [key: string] : string[]; } | null;
    length?: number | null;
    name?: string | null;
    fileName?: string | null;

    constructor(data?: IIFormFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contentType = data["ContentType"] !== undefined ? data["ContentType"] : <any>null;
            this.contentDisposition = data["ContentDisposition"] !== undefined ? data["ContentDisposition"] : <any>null;
            if (data["Headers"]) {
                this.headers = {} as any;
                for (let key in data["Headers"]) {
                    if (data["Headers"].hasOwnProperty(key))
                        this.headers![key] = data["Headers"][key] !== undefined ? data["Headers"][key] : [];
                }
            }
            this.length = data["Length"] !== undefined ? data["Length"] : <any>null;
            this.name = data["Name"] !== undefined ? data["Name"] : <any>null;
            this.fileName = data["FileName"] !== undefined ? data["FileName"] : <any>null;
        }
    }

    static fromJS(data: any): IFormFile {
        data = typeof data === 'object' ? data : {};
        let result = new IFormFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ContentType"] = this.contentType !== undefined ? this.contentType : <any>null;
        data["ContentDisposition"] = this.contentDisposition !== undefined ? this.contentDisposition : <any>null;
        if (this.headers) {
            data["Headers"] = {};
            for (let key in this.headers) {
                if (this.headers.hasOwnProperty(key))
                    data["Headers"][key] = this.headers[key] !== undefined ? this.headers[key] : <any>null;
            }
        }
        data["Length"] = this.length !== undefined ? this.length : <any>null;
        data["Name"] = this.name !== undefined ? this.name : <any>null;
        data["FileName"] = this.fileName !== undefined ? this.fileName : <any>null;
        return data; 
    }
}

export interface IIFormFile {
    contentType?: string | null;
    contentDisposition?: string | null;
    headers?: { [key: string] : string[]; } | null;
    length?: number | null;
    name?: string | null;
    fileName?: string | null;
}

export class UploadResult implements IUploadResult {
    errors?: { [key: string] : string; } | null;
    message?: string | null;
    operation?: string | null;

    constructor(data?: IUploadResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["Errors"]) {
                this.errors = {} as any;
                for (let key in data["Errors"]) {
                    if (data["Errors"].hasOwnProperty(key))
                        this.errors![key] = data["Errors"][key];
                }
            }
            this.message = data["Message"] !== undefined ? data["Message"] : <any>null;
            this.operation = data["Operation"] !== undefined ? data["Operation"] : <any>null;
        }
    }

    static fromJS(data: any): UploadResult {
        data = typeof data === 'object' ? data : {};
        let result = new UploadResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.errors) {
            data["Errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    data["Errors"][key] = this.errors[key] !== undefined ? this.errors[key] : <any>null;
            }
        }
        data["Message"] = this.message !== undefined ? this.message : <any>null;
        data["Operation"] = this.operation !== undefined ? this.operation : <any>null;
        return data; 
    }
}

export interface IUploadResult {
    errors?: { [key: string] : string; } | null;
    message?: string | null;
    operation?: string | null;
}

export class UnAssociateFile implements IUnAssociateFile {
    operationId?: string | null;
    fileName?: string | null;

    constructor(data?: IUnAssociateFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.operationId = data["OperationId"] !== undefined ? data["OperationId"] : <any>null;
            this.fileName = data["FileName"] !== undefined ? data["FileName"] : <any>null;
        }
    }

    static fromJS(data: any): UnAssociateFile {
        data = typeof data === 'object' ? data : {};
        let result = new UnAssociateFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["OperationId"] = this.operationId !== undefined ? this.operationId : <any>null;
        data["FileName"] = this.fileName !== undefined ? this.fileName : <any>null;
        return data; 
    }
}

export interface IUnAssociateFile {
    operationId?: string | null;
    fileName?: string | null;
}

export class AssociateFile implements IAssociateFile {
    operationId?: string | null;
    jobNumber?: string | null;

    constructor(data?: IAssociateFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.operationId = data["OperationId"] !== undefined ? data["OperationId"] : <any>null;
            this.jobNumber = data["JobNumber"] !== undefined ? data["JobNumber"] : <any>null;
        }
    }

    static fromJS(data: any): AssociateFile {
        data = typeof data === 'object' ? data : {};
        let result = new AssociateFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["OperationId"] = this.operationId !== undefined ? this.operationId : <any>null;
        data["JobNumber"] = this.jobNumber !== undefined ? this.jobNumber : <any>null;
        return data; 
    }
}

export interface IAssociateFile {
    operationId?: string | null;
    jobNumber?: string | null;
}

export class FileToNameTemplate implements IFileToNameTemplate {
    templateHtml?: string | null;
    submitButtonContent?: string | null;
    baseRowId?: string | null;
    errorCol?: string | null;
    errorColSpan?: string | null;
    fileNameSpan?: string | null;
    editorId?: string | null;
    submitButton?: string | null;

    constructor(data?: IFileToNameTemplate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.templateHtml = data["TemplateHtml"] !== undefined ? data["TemplateHtml"] : <any>null;
            this.submitButtonContent = data["SubmitButtonContent"] !== undefined ? data["SubmitButtonContent"] : <any>null;
            this.baseRowId = data["BaseRowId"] !== undefined ? data["BaseRowId"] : <any>null;
            this.errorCol = data["ErrorCol"] !== undefined ? data["ErrorCol"] : <any>null;
            this.errorColSpan = data["ErrorColSpan"] !== undefined ? data["ErrorColSpan"] : <any>null;
            this.fileNameSpan = data["FileNameSpan"] !== undefined ? data["FileNameSpan"] : <any>null;
            this.editorId = data["EditorId"] !== undefined ? data["EditorId"] : <any>null;
            this.submitButton = data["SubmitButton"] !== undefined ? data["SubmitButton"] : <any>null;
        }
    }

    static fromJS(data: any): FileToNameTemplate {
        data = typeof data === 'object' ? data : {};
        let result = new FileToNameTemplate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TemplateHtml"] = this.templateHtml !== undefined ? this.templateHtml : <any>null;
        data["SubmitButtonContent"] = this.submitButtonContent !== undefined ? this.submitButtonContent : <any>null;
        data["BaseRowId"] = this.baseRowId !== undefined ? this.baseRowId : <any>null;
        data["ErrorCol"] = this.errorCol !== undefined ? this.errorCol : <any>null;
        data["ErrorColSpan"] = this.errorColSpan !== undefined ? this.errorColSpan : <any>null;
        data["FileNameSpan"] = this.fileNameSpan !== undefined ? this.fileNameSpan : <any>null;
        data["EditorId"] = this.editorId !== undefined ? this.editorId : <any>null;
        data["SubmitButton"] = this.submitButton !== undefined ? this.submitButton : <any>null;
        return data; 
    }
}

export interface IFileToNameTemplate {
    templateHtml?: string | null;
    submitButtonContent?: string | null;
    baseRowId?: string | null;
    errorCol?: string | null;
    errorColSpan?: string | null;
    fileNameSpan?: string | null;
    editorId?: string | null;
    submitButton?: string | null;
}

export class UserList implements IUserList {
    items?: AppUser[] | null;
    count?: number | null;

    constructor(data?: IUserList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["Items"] && data["Items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["Items"])
                    this.items!.push(AppUser.fromJS(item));
            }
            this.count = data["Count"] !== undefined ? data["Count"] : <any>null;
        }
    }

    static fromJS(data: any): UserList {
        data = typeof data === 'object' ? data : {};
        let result = new UserList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["Items"] = [];
            for (let item of this.items)
                data["Items"].push(item.toJSON());
        }
        data["Count"] = this.count !== undefined ? this.count : <any>null;
        return data; 
    }
}

export interface IUserList {
    items?: AppUser[] | null;
    count?: number | null;
}

export class AppUser implements IAppUser {
    id?: string | null;
    email?: string | null;
    name?: string | null;
    role?: string | null;

    constructor(data?: IAppUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"] !== undefined ? data["Id"] : <any>null;
            this.email = data["Email"] !== undefined ? data["Email"] : <any>null;
            this.name = data["Name"] !== undefined ? data["Name"] : <any>null;
            this.role = data["Role"] !== undefined ? data["Role"] : <any>null;
        }
    }

    static fromJS(data: any): AppUser {
        data = typeof data === 'object' ? data : {};
        let result = new AppUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id !== undefined ? this.id : <any>null;
        data["Email"] = this.email !== undefined ? this.email : <any>null;
        data["Name"] = this.name !== undefined ? this.name : <any>null;
        data["Role"] = this.role !== undefined ? this.role : <any>null;
        return data; 
    }
}

export interface IAppUser {
    id?: string | null;
    email?: string | null;
    name?: string | null;
    role?: string | null;
}

export class DataManagerRequest implements IDataManagerRequest {
    skip?: number | null;
    take?: number | null;
    antiForgery?: string | null;
    requiresCounts?: boolean | null;
    table?: string | null;
    group?: string[] | null;
    select?: string[] | null;
    expand?: string[] | null;
    sorted?: Sort[] | null;
    search?: SearchFilter[] | null;
    where?: WhereFilter[] | null;
    aggregates?: Aggregate[] | null;

    constructor(data?: IDataManagerRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.skip = data["skip"] !== undefined ? data["skip"] : <any>null;
            this.take = data["take"] !== undefined ? data["take"] : <any>null;
            this.antiForgery = data["antiForgery"] !== undefined ? data["antiForgery"] : <any>null;
            this.requiresCounts = data["requiresCounts"] !== undefined ? data["requiresCounts"] : <any>null;
            this.table = data["table"] !== undefined ? data["table"] : <any>null;
            if (data["group"] && data["group"].constructor === Array) {
                this.group = [] as any;
                for (let item of data["group"])
                    this.group!.push(item);
            }
            if (data["select"] && data["select"].constructor === Array) {
                this.select = [] as any;
                for (let item of data["select"])
                    this.select!.push(item);
            }
            if (data["expand"] && data["expand"].constructor === Array) {
                this.expand = [] as any;
                for (let item of data["expand"])
                    this.expand!.push(item);
            }
            if (data["sorted"] && data["sorted"].constructor === Array) {
                this.sorted = [] as any;
                for (let item of data["sorted"])
                    this.sorted!.push(Sort.fromJS(item));
            }
            if (data["search"] && data["search"].constructor === Array) {
                this.search = [] as any;
                for (let item of data["search"])
                    this.search!.push(SearchFilter.fromJS(item));
            }
            if (data["where"] && data["where"].constructor === Array) {
                this.where = [] as any;
                for (let item of data["where"])
                    this.where!.push(WhereFilter.fromJS(item));
            }
            if (data["aggregates"] && data["aggregates"].constructor === Array) {
                this.aggregates = [] as any;
                for (let item of data["aggregates"])
                    this.aggregates!.push(Aggregate.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DataManagerRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DataManagerRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skip"] = this.skip !== undefined ? this.skip : <any>null;
        data["take"] = this.take !== undefined ? this.take : <any>null;
        data["antiForgery"] = this.antiForgery !== undefined ? this.antiForgery : <any>null;
        data["requiresCounts"] = this.requiresCounts !== undefined ? this.requiresCounts : <any>null;
        data["table"] = this.table !== undefined ? this.table : <any>null;
        if (this.group && this.group.constructor === Array) {
            data["group"] = [];
            for (let item of this.group)
                data["group"].push(item);
        }
        if (this.select && this.select.constructor === Array) {
            data["select"] = [];
            for (let item of this.select)
                data["select"].push(item);
        }
        if (this.expand && this.expand.constructor === Array) {
            data["expand"] = [];
            for (let item of this.expand)
                data["expand"].push(item);
        }
        if (this.sorted && this.sorted.constructor === Array) {
            data["sorted"] = [];
            for (let item of this.sorted)
                data["sorted"].push(item.toJSON());
        }
        if (this.search && this.search.constructor === Array) {
            data["search"] = [];
            for (let item of this.search)
                data["search"].push(item.toJSON());
        }
        if (this.where && this.where.constructor === Array) {
            data["where"] = [];
            for (let item of this.where)
                data["where"].push(item.toJSON());
        }
        if (this.aggregates && this.aggregates.constructor === Array) {
            data["aggregates"] = [];
            for (let item of this.aggregates)
                data["aggregates"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDataManagerRequest {
    skip?: number | null;
    take?: number | null;
    antiForgery?: string | null;
    requiresCounts?: boolean | null;
    table?: string | null;
    group?: string[] | null;
    select?: string[] | null;
    expand?: string[] | null;
    sorted?: Sort[] | null;
    search?: SearchFilter[] | null;
    where?: WhereFilter[] | null;
    aggregates?: Aggregate[] | null;
}

export class Sort implements ISort {
    name?: string | null;
    direction?: string | null;

    constructor(data?: ISort) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["Name"] !== undefined ? data["Name"] : <any>null;
            this.direction = data["Direction"] !== undefined ? data["Direction"] : <any>null;
        }
    }

    static fromJS(data: any): Sort {
        data = typeof data === 'object' ? data : {};
        let result = new Sort();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name !== undefined ? this.name : <any>null;
        data["Direction"] = this.direction !== undefined ? this.direction : <any>null;
        return data; 
    }
}

export interface ISort {
    name?: string | null;
    direction?: string | null;
}

export class SearchFilter implements ISearchFilter {
    fields?: string[] | null;
    key?: string | null;
    operator?: string | null;

    constructor(data?: ISearchFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["Fields"] && data["Fields"].constructor === Array) {
                this.fields = [] as any;
                for (let item of data["Fields"])
                    this.fields!.push(item);
            }
            this.key = data["Key"] !== undefined ? data["Key"] : <any>null;
            this.operator = data["Operator"] !== undefined ? data["Operator"] : <any>null;
        }
    }

    static fromJS(data: any): SearchFilter {
        data = typeof data === 'object' ? data : {};
        let result = new SearchFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.fields && this.fields.constructor === Array) {
            data["Fields"] = [];
            for (let item of this.fields)
                data["Fields"].push(item);
        }
        data["Key"] = this.key !== undefined ? this.key : <any>null;
        data["Operator"] = this.operator !== undefined ? this.operator : <any>null;
        return data; 
    }
}

export interface ISearchFilter {
    fields?: string[] | null;
    key?: string | null;
    operator?: string | null;
}

export class WhereFilter implements IWhereFilter {
    field?: string | null;
    ignoreCase?: boolean | null;
    isComplex?: boolean | null;
    operator?: string | null;
    condition?: string | null;
    value?: any | null;
    predicates?: WhereFilter[] | null;

    constructor(data?: IWhereFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.field = data["Field"] !== undefined ? data["Field"] : <any>null;
            this.ignoreCase = data["IgnoreCase"] !== undefined ? data["IgnoreCase"] : <any>null;
            this.isComplex = data["IsComplex"] !== undefined ? data["IsComplex"] : <any>null;
            this.operator = data["Operator"] !== undefined ? data["Operator"] : <any>null;
            this.condition = data["Condition"] !== undefined ? data["Condition"] : <any>null;
            this.value = data["value"] !== undefined ? data["value"] : <any>null;
            if (data["predicates"] && data["predicates"].constructor === Array) {
                this.predicates = [] as any;
                for (let item of data["predicates"])
                    this.predicates!.push(WhereFilter.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WhereFilter {
        data = typeof data === 'object' ? data : {};
        let result = new WhereFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Field"] = this.field !== undefined ? this.field : <any>null;
        data["IgnoreCase"] = this.ignoreCase !== undefined ? this.ignoreCase : <any>null;
        data["IsComplex"] = this.isComplex !== undefined ? this.isComplex : <any>null;
        data["Operator"] = this.operator !== undefined ? this.operator : <any>null;
        data["Condition"] = this.condition !== undefined ? this.condition : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        if (this.predicates && this.predicates.constructor === Array) {
            data["predicates"] = [];
            for (let item of this.predicates)
                data["predicates"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IWhereFilter {
    field?: string | null;
    ignoreCase?: boolean | null;
    isComplex?: boolean | null;
    operator?: string | null;
    condition?: string | null;
    value?: any | null;
    predicates?: WhereFilter[] | null;
}

export class Aggregate implements IAggregate {
    field?: string | null;
    type?: string | null;

    constructor(data?: IAggregate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.field = data["Field"] !== undefined ? data["Field"] : <any>null;
            this.type = data["Type"] !== undefined ? data["Type"] : <any>null;
        }
    }

    static fromJS(data: any): Aggregate {
        data = typeof data === 'object' ? data : {};
        let result = new Aggregate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Field"] = this.field !== undefined ? this.field : <any>null;
        data["Type"] = this.type !== undefined ? this.type : <any>null;
        return data; 
    }
}

export interface IAggregate {
    field?: string | null;
    type?: string | null;
}

export class AppUserValue implements IAppUserValue {
    value?: AppUser | null;

    constructor(data?: IAppUserValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["Value"] ? AppUser.fromJS(data["Value"]) : <any>null;
        }
    }

    static fromJS(data: any): AppUserValue {
        data = typeof data === 'object' ? data : {};
        let result = new AppUserValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Value"] = this.value ? this.value.toJSON() : <any>null;
        return data; 
    }
}

export interface IAppUserValue {
    value?: AppUser | null;
}

export class AppUserKey implements IAppUserKey {
    key?: string | null;

    constructor(data?: IAppUserKey) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["Key"] !== undefined ? data["Key"] : <any>null;
        }
    }

    static fromJS(data: any): AppUserKey {
        data = typeof data === 'object' ? data : {};
        let result = new AppUserKey();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Key"] = this.key !== undefined ? this.key : <any>null;
        return data; 
    }
}

export interface IAppUserKey {
    key?: string | null;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if(result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}

}